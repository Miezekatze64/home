# Fold - A functional programming language

A (purely) functional programming language

This language is being developed as part of a [ABA](https://www.ahs-aba.at/).

## Features
- [x] working parser
- [x] basic syntax (expressions, function application)
- [x] compilation to combinator graph
- [x] reduction/interpretation of graph
- [x] type inference (hindley-milner)
- [x] let bindings
- [x] garbage collection
- [x] sections (*1), (-2), ...
- [x] lambda functions
- [x] data structures
- [x] lists / strings
- [x] char stdlib (char <-> int)?
- [x] comments
- [x] interfaces, type classes, etc
- [x] inference of "type classes"
- [x] standard library
- [x] extern function calls / FFI
- [x] I/O
- [x] compilation to SKIBC
- [x] name
- [x] forward declarations
- [x] entry point that calls main using forward declaration with io type. 
- [x] &{entry} pragma to change main function name
- [x] NodeJS target
- [ ] &{global} pragma for type definitions (makes all constructors globally available \[e. g. true === bool::true, ...\])
- [ ] autogenerated instances (either pragma or metaprogramming over type fields)
- [ ] -infix- syntax
- [ ] `x y => f x y` as syntactic sugar for `x => y => f x y`
- [ ] scope for alias/macro \[type/kind/expr\]
- [ ] `_` for discard
- [ ] pattern matching on function definition
- [ ] syntax for applying and capturing interface dictionaries
- [ ] a way of creating custom constraints (with checks for uniqueness / explicit instances)
- [ ] ...

## TODOs
- [x] fix nested let and lambda bugs
- [x] change method to return values in direct-exec compiler, currently does not update graph, values are computated too many
      times, probably biggest performance bottleneck there currently
- [ ] toplevel dependency analysis, fixes hoisting bug (maybe per namespace?)
- [ ] disallow ::prim namespace
- [ ] throw error when using qualified variable in pattern that is not constructor
- [ ] disallow duplicate definitions in `main`
- [ ] fix associativity bug (right + left mixed causes bugs, if possible rework operator resolution completely).
- [ ] better type annotation syntax (let f (x: int): int = x)
- [ ] implicit match \[let f = match { .. } => let f = x => match x { ... }\]
- [ ] allow freestanding type annotations
- [ ] list patterns
- [ ] change toplevel syntax to not use let as semantics are different (maybe def?)
- [ ] allow pattern matching on function/let definition \[some kind of guard syntax, maybe allow bools here too, would require bool pragma\]
- [ ] fix bug in TIGRE-native GC implementation (see 04-raylib)
- [ ] rewrite this entire codebase in a more readable style \[e.g. mtl\]
- [ ] introduce better string type
- [ ] introduce fast-path for int-to-string, currently slowest part in 02-factorial.fl
- [ ] make kinds equivalent to types, infer kinds (=types of types)
- [ ] dependent types?
- [ ] ...

<p class="todo">The REPL is currently in a sleeping state and does *not* support newer 
features like the preservation of type classes over multiple lines.
Use it at your own risk.</p>

## Usage
```sh
# cabal 3.12.1.0, ghc 9.10.1 (installed via GHCup)
cabal update
# run
./build.sh run main.fl
# or
./build.sh
./target/foldc main.fl

# interpret [GENERALLY RECOMMENDED]
./target/foldc main.fl
# native compilation [x86_64 linux, A BIT UNSTABLE]
./target/foldc --compile main.fl && ./main
# node js [RECOMMENDED FOR SPPED]
./target/foldc --js main.fl && node ./main.js
```

### Docker

```sh
docker build --tag fold:foldc .
docker run -v .:/tmp/share -it fold:foldc
/opt/foldc/target/foldc /tmp/share/main.fl
# or
/opt/foldc/target/foldc --compile /tmp/share/main.fl
/tmp/share/main
```

## Contributing
see [CONTRIBUTING]

[CONTRIBUTING]: CONTRIBUTING.md
